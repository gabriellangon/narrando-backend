[
  {
    "function_name": "narrando_api_base_url",
    "parameters": "",
    "return_type": "text",
    "full_definition": "CREATE OR REPLACE FUNCTION public.narrando_api_base_url()\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nDECLARE\n    configured_url TEXT;\nBEGIN\n    configured_url := current_setting('app.narrando_api_base_url', true);\n    RETURN COALESCE(NULLIF(configured_url, ''), 'http://localhost:5000');\nEND;\n$function$"
  },
  {
    "function_name": "check_tour_generation_status",
    "parameters": "tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.check_tour_generation_status(tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    total_points INTEGER;\n    points_with_audio INTEGER;\n    processing_record RECORD;\n    user_has_purchase BOOLEAN;\n    owned_languages json := '[]'::json;\nBEGIN\n    PERFORM set_config('request.jwt.claim.role', 'service_role', true);\n    language_code_param := COALESCE(NULLIF(language_code_param, ''), 'en');\n\n    -- 1. Verify the user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE id = user_id_param) THEN\n        RETURN json_build_object(\n            'status', 'not_started',\n            'total_points', 0,\n            'completed_points', 0,\n            'user_has_purchase', false,\n            'narration_type', narration_type_param,\n            'language_code', language_code_param,\n            'message', 'Ready to generate tour audio',\n            'owned_languages', '[]'::json\n        );\n    END IF;\n\n    -- 2. Check existing purchase for this narration/language\n    SELECT EXISTS(\n        SELECT 1\n        FROM tour_purchases\n        WHERE user_id = user_id_param\n          AND tour_id = tour_id_param\n          AND narration_type = narration_type_param\n          AND language_code = language_code_param\n          AND quantity_total > quantity_gifted\n    ) INTO user_has_purchase;\n\n    SELECT COALESCE(json_agg(\n        json_build_object(\n            'language_code', tp.language_code,\n            'purchase_id', tp.id\n        )\n    ), '[]'::json)\n    INTO owned_languages\n    FROM tour_purchases tp\n    WHERE tp.user_id = user_id_param\n      AND tp.tour_id = tour_id_param\n      AND tp.narration_type = narration_type_param\n      AND tp.quantity_total > tp.quantity_gifted;\n\n    -- 3. Count how many points already have audio in this language\n    SELECT\n        COUNT(*) AS total,\n        COUNT(\n            CASE\n                WHEN COALESCE(at_trans.audio_url, a.audio_url)->>narration_type_param IS NOT NULL THEN 1\n            END\n        ) AS with_audio\n    INTO total_points, points_with_audio\n    FROM tour_points tp\n    JOIN attractions a ON tp.attraction_id = a.id\n    LEFT JOIN attraction_translations at_trans\n      ON at_trans.attraction_id = a.id\n     AND at_trans.language_code = language_code_param\n    WHERE tp.tour_id = tour_id_param;\n\n    IF total_points > 0 AND total_points = points_with_audio THEN\n        RETURN json_build_object(\n            'status', 'ready',\n            'total_points', total_points,\n            'completed_points', points_with_audio,\n            'user_has_purchase', user_has_purchase,\n            'narration_type', narration_type_param,\n            'language_code', language_code_param,\n            'message', 'All tour audio files are ready',\n            'owned_languages', owned_languages\n        );\n    END IF;\n\n    -- 4. Look for an ongoing processing record\n    SELECT * INTO processing_record\n    FROM processing_tour_generation\n    WHERE tour_id = tour_id_param\n      AND narration_type = narration_type_param\n      AND language_code = language_code_param;\n\n    IF FOUND THEN\n        IF processing_record.requested_at < NOW() - INTERVAL '5 minutes' THEN\n            DELETE FROM processing_tour_generation\n            WHERE tour_id = tour_id_param\n              AND narration_type = narration_type_param\n              AND language_code = language_code_param;\n\n            RETURN json_build_object(\n                'status', 'not_started',\n                'total_points', total_points,\n                'completed_points', points_with_audio,\n                'user_has_purchase', user_has_purchase,\n                'narration_type', narration_type_param,\n                'language_code', language_code_param,\n                'message', 'Generation not started',\n                'owned_languages', owned_languages\n            );\n        ELSE\n            RETURN json_build_object(\n                'status', 'processing',\n                'requested_at', processing_record.requested_at,\n                'total_points', total_points,\n                'completed_points', points_with_audio,\n                'user_has_purchase', user_has_purchase,\n                'narration_type', narration_type_param,\n                'language_code', language_code_param,\n                'message', 'Tour audio generation in progress...',\n\t\t\t\t'progress_percent', processing_record.progress_percent,\n                'owned_languages', owned_languages\n            );\n        END IF;\n    END IF;\n\n    RETURN json_build_object(\n        'status', 'not_started',\n        'total_points', total_points,\n        'completed_points', points_with_audio,\n        'user_has_purchase', user_has_purchase,\n        'narration_type', narration_type_param,\n        'language_code', language_code_param,\n        'message', 'Generation not started',\n        'owned_languages', owned_languages\n    );\nEND;\n$function$\n"
  },
  {
    "function_name": "claim_pending_invitations",
    "parameters": "p_user_id uuid, p_email text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.claim_pending_invitations(p_user_id uuid, p_email text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    normalized_email text := lower(trim(p_email));\n    claimed_count integer := 0;\n    invitation_record RECORD;\nBEGIN\n    IF p_user_id IS NULL THEN\n        RETURN json_build_object('success', false, 'claimed', 0, 'message', 'user id is required');\n    END IF;\n\n    IF normalized_email IS NULL OR normalized_email = '' THEN\n        RETURN json_build_object('success', false, 'claimed', 0, 'message', 'email is required');\n    END IF;\n\n    FOR invitation_record IN\n        SELECT\n            ti.id,\n            ti.tour_purchase_id,\n            tp.tour_id,\n            tp.narration_type,\n            tp.language_code\n        FROM tour_invitations ti\n        JOIN tour_purchases tp ON tp.id = ti.tour_purchase_id\n        WHERE ti.status = 'pending'\n          AND lower(ti.recipient_email) = normalized_email\n        FOR UPDATE\n    LOOP\n        INSERT INTO tour_purchases (\n            user_id,\n            tour_id,\n            quantity_total,\n            quantity_completed,\n            quantity_gifted,\n            source,\n            narration_type,\n            language_code\n        )\n        VALUES (\n            p_user_id,\n            invitation_record.tour_id,\n            1,\n            0,\n            0,\n            'gift',\n            invitation_record.narration_type,\n            invitation_record.language_code\n        );\n\n        UPDATE tour_invitations\n        SET status = 'accepted',\n            recipient_id = p_user_id,\n            accepted_date = NOW(),\n            updated_at = NOW()\n        WHERE id = invitation_record.id;\n\n        claimed_count := claimed_count + 1;\n    END LOOP;\n\n    RETURN json_build_object(\n        'success', true,\n        'claimed', claimed_count\n    );\nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN json_build_object(\n            'success', false,\n            'claimed', claimed_count,\n            'message', SQLERRM\n        );\nEND;\n$function$\n"
  },
  {
    "function_name": "clean_city_data",
    "parameters": "city_place_id text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.clean_city_data(city_place_id text)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  v_city_id UUID;\n  v_walking_paths_count INT;\n  v_tour_points_count INT;\n  v_guided_tours_count INT;\n  v_attractions_count INT;\n  v_processing_city_count INT;\n  v_city_name TEXT;\n  v_country TEXT;\nBEGIN\n  -- Récupérer les infos de la ville\n  SELECT id, city, country INTO v_city_id, v_city_name, v_country\n  FROM cities\n  WHERE place_id = city_place_id;\n\n  -- Si la ville n'existe pas, retourner une erreur\n  IF v_city_id IS NULL THEN\n    RETURN json_build_object(\n      'success', false,\n      'error', 'City not found with place_id: ' || city_place_id\n    );\n  END IF;\n\n  -- 1. Supprimer les walking_paths liés aux tours de cette ville\n  DELETE FROM walking_paths\n  WHERE tour_id IN (\n    SELECT id FROM guided_tours \n    WHERE city_id = v_city_id\n  );\n  GET DIAGNOSTICS v_walking_paths_count = ROW_COUNT;\n\n  -- 2. Supprimer les tour_points liés aux tours de cette ville\n  DELETE FROM tour_points\n  WHERE tour_id IN (\n    SELECT id FROM guided_tours \n    WHERE city_id = v_city_id\n  );\n  GET DIAGNOSTICS v_tour_points_count = ROW_COUNT;\n\n  -- 3. Supprimer les guided_tours de cette ville\n  DELETE FROM guided_tours\n  WHERE city_id = v_city_id;\n  GET DIAGNOSTICS v_guided_tours_count = ROW_COUNT;\n\n  -- 4. Supprimer les attractions de cette ville\n  DELETE FROM attractions\n  WHERE city_id = v_city_id;\n  GET DIAGNOSTICS v_attractions_count = ROW_COUNT;\n\n  -- 5. Supprimer l'entrée de traitement (si existe)\n  DELETE FROM processing_city\n  WHERE place_id = city_place_id;\n  GET DIAGNOSTICS v_processing_city_count = ROW_COUNT;\n\n  -- 6. Supprimer la ville elle-même\n  DELETE FROM cities\n  WHERE place_id = city_place_id;\n\n  -- Retourner le résumé\n  RETURN json_build_object(\n    'success', true,\n    'city', v_city_name,\n    'country', v_country,\n    'place_id', city_place_id,\n    'deleted', json_build_object(\n      'walking_paths', v_walking_paths_count,\n      'tour_points', v_tour_points_count,\n      'guided_tours', v_guided_tours_count,\n      'attractions', v_attractions_count,\n      'processing_city', v_processing_city_count,\n      'city', 1\n    )\n  );\nEND;\n$function$\n"
  },
  {
    "function_name": "cleanup_stale_audio_processing",
    "parameters": "",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.cleanup_stale_audio_processing()\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$DECLARE\n    deleted_preview INTEGER;\n    deleted_generation INTEGER;\nBEGIN\n\n -- Elevate role to satisfy service-role-only RLS policies during writes\n    PERFORM set_config('request.jwt.claim.role', 'service_role', true);\n\n    DELETE FROM processing_tour_preview WHERE requested_at < NOW() - INTERVAL '10 minutes';\n    GET DIAGNOSTICS deleted_preview = ROW_COUNT;\n    \n    DELETE FROM processing_tour_generation WHERE requested_at < NOW() - INTERVAL '15 minutes';\n    GET DIAGNOSTICS deleted_generation = ROW_COUNT;\n    \n    RETURN json_build_object(\n        'cleaned_preview', deleted_preview,\n        'cleaned_generation', deleted_generation\n    );\nEND;$function$\n"
  },
  {
    "function_name": "cleanup_stale_processing",
    "parameters": "",
    "return_type": "integer",
    "full_definition": "CREATE OR REPLACE FUNCTION public.cleanup_stale_processing()\n RETURNS integer\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    deleted_count INTEGER;\nBEGIN\n    DELETE FROM processing_city \n    WHERE requested_at < NOW() - INTERVAL '10 minutes';\n    \n    GET DIAGNOSTICS deleted_count = ROW_COUNT;\n    RETURN deleted_count;\nEND;\n$function$\n"
  },
  {
    "function_name": "consume_tour_credits_for_generation",
    "parameters": "tour_id_param uuid, user_id_param uuid",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.consume_tour_credits_for_generation(tour_id_param uuid, user_id_param uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    required_credits INTEGER;\n    updated_user RECORD;\nBEGIN\n    PERFORM set_config('request.jwt.claim.role', 'service_role', true);\n\n    SELECT COUNT(*)\n    INTO required_credits\n    FROM tour_points\n    WHERE tour_id = tour_id_param;\n\n    IF required_credits <= 0 THEN\n        RETURN json_build_object(\n            'success', false,\n            'message', 'Tour has no attractions to generate',\n            'required_credits', 0\n        );\n    END IF;\n\n    UPDATE users\n    SET credits = credits - required_credits,\n        updated_at = NOW()\n    WHERE id = user_id_param\n      AND credits >= required_credits\n    RETURNING credits\n    INTO updated_user;\n\n    IF NOT FOUND THEN\n        RETURN json_build_object(\n            'success', false,\n            'message', 'Insufficient credits',\n            'required_credits', required_credits\n        );\n    END IF;\n\n    RETURN json_build_object(\n        'success', true,\n        'required_credits', required_credits,\n        'remaining_credits', updated_user.credits\n    );\nEND;\n$function$\n"
  },
  {
    "function_name": "get_active_tour_model",
    "parameters": "tour_id_param uuid, language_code_param text DEFAULT 'en'::text",
    "return_type": "jsonb",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_active_tour_model(tour_id_param uuid, language_code_param text DEFAULT 'en'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  walking_paths JSONB;\n  last_point JSONB;\n  result JSONB;\nBEGIN\n  WITH ordered_paths AS (\n    SELECT\n      wp.id AS walking_path_id,\n      wp.tour_id,\n      wp.path_coordinates,\n      wp.to_attraction_id,\n      tp.point_order,\n      ROW_NUMBER() OVER (\n        ORDER BY COALESCE(tp.point_order, from_attr.route_index, 999999), wp.id\n      ) AS path_order,\n      from_attr.id AS from_attraction_id,\n      from_attr.place_id AS from_place_id,\n      from_attr.formatted_address AS from_formatted_address,\n      from_attr.lat AS from_lat,\n      from_attr.lng AS from_lng,\n      from_attr.ai_evaluation_timestamp AS from_ai_evaluation_timestamp,\n      from_attr.rating AS from_rating,\n      from_attr.types AS from_types,\n      from_attr.photos AS from_photos,\n      COALESCE(from_trans.audio_url, from_attr.audio_url) AS from_audio_url,\n      from_attr.route_index AS from_route_index,\n      COALESCE(from_trans.name, from_attr.name) AS from_name,\n      COALESCE(from_trans.ai_description::jsonb, from_attr.ai_description) AS from_ai_description\n    FROM walking_paths wp\n    JOIN attractions from_attr\n      ON wp.from_attraction_id = from_attr.id\n    LEFT JOIN attraction_translations from_trans\n      ON from_trans.attraction_id = from_attr.id\n      AND from_trans.language_code = language_code_param\n    LEFT JOIN tour_points tp\n      ON tp.tour_id = wp.tour_id\n     AND tp.attraction_id = wp.from_attraction_id\n    WHERE wp.tour_id = tour_id_param\n  ),\n  walking_paths_cte AS (\n    SELECT jsonb_agg(\n             jsonb_build_object(\n               'walking_path_id', op.walking_path_id,\n               'tour_id', op.tour_id,\n               'path_coordinates', op.path_coordinates,\n               'from_attraction', jsonb_build_object(\n                 'id', op.from_attraction_id,\n                 'place_id', op.from_place_id,\n                 'name', op.from_name,\n                 'formatted_address', op.from_formatted_address,\n                 'location', jsonb_build_object(\n                   'lat', op.from_lat::numeric,\n                   'lng', op.from_lng::numeric\n                 ),\n                 'ai_description', op.from_ai_description,\n                 'ai_evaluation_timestamp', op.from_ai_evaluation_timestamp,\n                 'rating', op.from_rating,\n                 'types', op.from_types,\n                 'photos', op.from_photos,\n                 'audio_url', op.from_audio_url\n               ),\n               'to_attraction_id', op.to_attraction_id\n             )\n             ORDER BY COALESCE(op.point_order, op.path_order)\n           ) AS walking_paths\n    FROM ordered_paths op\n  ),\n  last_point_cte AS (\n    SELECT jsonb_build_object(\n             'id', dest.id,\n             'place_id', dest.place_id,\n             'name', COALESCE(dest_trans.name, dest.name),\n             'formatted_address', dest.formatted_address,\n             'location', jsonb_build_object('lat', dest.lat::numeric, 'lng', dest.lng::numeric),\n             'ai_description', COALESCE(dest_trans.ai_description::jsonb, dest.ai_description),\n             'photos', dest.photos,\n             'rating', dest.rating,\n             'types', dest.types,\n             'audio_url', COALESCE(dest_trans.audio_url, dest.audio_url)\n           ) AS last_point\n    FROM ordered_paths op\n    JOIN attractions dest\n      ON dest.id = op.to_attraction_id\n    LEFT JOIN attraction_translations dest_trans\n      ON dest_trans.attraction_id = dest.id\n      AND dest_trans.language_code = language_code_param\n    LEFT JOIN tour_points tp_end\n      ON tp_end.tour_id = op.tour_id\n     AND tp_end.attraction_id = op.to_attraction_id\n    WHERE op.to_attraction_id IS NOT NULL\n    ORDER BY COALESCE(tp_end.point_order, op.point_order, op.path_order) DESC\n    LIMIT 1\n  )\n  SELECT walking_paths_cte.walking_paths,\n         last_point_cte.last_point\n  INTO walking_paths, last_point\n  FROM walking_paths_cte\n  LEFT JOIN last_point_cte ON TRUE;\n\n  IF walking_paths IS NULL THEN\n    RETURN NULL;\n  END IF;\n\n  IF jsonb_array_length(walking_paths) = 0 THEN\n    RETURN NULL;\n  END IF;\n\n  result := jsonb_build_object(\n    'walking_paths', walking_paths,\n    'last_point', last_point\n  );\n\n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_audio_sample",
    "parameters": "language_code_param text, narration_type_param text DEFAULT 'standard'::text",
    "return_type": "text",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_audio_sample(language_code_param text, narration_type_param text DEFAULT 'standard'::text)\n RETURNS text\n LANGUAGE plpgsql\n STABLE\nAS $function$\nDECLARE\n  sample_url text;\nBEGIN\n  SELECT audio_url->>narration_type_param\n  INTO sample_url\n  FROM audio_samples\n  WHERE language_code = language_code_param;\n\n  IF sample_url IS NULL THEN\n    SELECT audio_url->>narration_type_param\n    INTO sample_url\n    FROM audio_samples\n    WHERE language_code = 'en';\n  END IF;\n\n  RETURN sample_url;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_city_by_place_id",
    "parameters": "place_id_param text, language_code_param text DEFAULT 'en'::text",
    "return_type": "TABLE(id uuid, city character varying, country character varying, country_iso_code character varying, place_id text, created_at timestamp with time zone, updated_at timestamp with time zone)",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_city_by_place_id(place_id_param text, language_code_param text DEFAULT 'en'::text)\n RETURNS TABLE(id uuid, city character varying, country character varying, country_iso_code character varying, place_id text, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT\n    c.id,\n    COALESCE(ct.city, c.city) as city,\n    COALESCE(ct.country, c.country) as country,\n    c.country_iso_code,\n    c.place_id,\n    c.created_at,\n    c.updated_at\n  FROM cities c\n  LEFT JOIN city_translations ct\n    ON c.id = ct.city_id AND ct.language_code = language_code_param\n  WHERE c.place_id = place_id_param;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_city_tours_map",
    "parameters": "city_id_param uuid, language_code_param text DEFAULT 'en'::text",
    "return_type": "TABLE(city_id uuid, city_name character varying, tour_id uuid, tour_order integer, tour_name character varying, total_distance integer, estimated_walking_time integer, point_count integer, cover_photo jsonb, points jsonb)",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_city_tours_map(city_id_param uuid, language_code_param text DEFAULT 'en'::text)\n RETURNS TABLE(city_id uuid, city_name character varying, tour_id uuid, tour_order integer, tour_name character varying, total_distance integer, estimated_walking_time integer, point_count integer, cover_photo jsonb, points jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n  RETURN QUERY\n  WITH tour_points_expanded AS (\n    SELECT\n      gt.id as tour_id,\n      gt.city_id,\n      -- Use translation if available, fallback to default\n      COALESCE(gtt.tour_name, gt.tour_name) as tour_name,\n      gt.tour_id as tour_order,\n      gt.total_distance,\n      gt.estimated_walking_time,\n      gt.point_count,\n      tp.point_order,\n      tp.global_index,\n      ROW_NUMBER() OVER (PARTITION BY gt.id ORDER BY tp.point_order) as point_rank,\n      a.id as attraction_id,\n      -- Use translation if available, fallback to default\n      COALESCE(att.name, a.name) as attraction_name,\n      a.lat,\n      a.lng,\n      a.photos\n    FROM guided_tours gt\n    JOIN tour_points tp ON tp.tour_id = gt.id\n    JOIN attractions a ON a.id = tp.attraction_id\n    -- Join translation tables with language filter\n    LEFT JOIN guided_tour_translations gtt\n      ON gt.id = gtt.tour_id AND gtt.language_code = language_code_param\n    LEFT JOIN attraction_translations att\n      ON a.id = att.attraction_id AND att.language_code = language_code_param\n    WHERE gt.city_id = city_id_param\n  ),\n  cover_photos AS (\n    SELECT DISTINCT ON (tpe.tour_id)\n      tpe.tour_id,\n      CASE\n        WHEN tpe.photos IS NOT NULL\n             AND jsonb_typeof(tpe.photos) = 'array'\n             AND jsonb_array_length(tpe.photos) > 0\n        THEN jsonb_build_object(\n          'photo_reference', tpe.photos->0->>'photo_reference',\n          'height', NULLIF(tpe.photos->0->>'height', '')::int,\n          'width', NULLIF(tpe.photos->0->>'width', '')::int\n        )\n        ELSE NULL\n      END AS cover_photo\n    FROM tour_points_expanded tpe\n    ORDER BY tpe.tour_id, tpe.point_rank\n  )\n  SELECT\n    t.city_id,\n    COALESCE(ct.city, c.city) as city_name,\n    t.tour_id,\n    t.tour_order,\n    t.tour_name,\n    t.total_distance,\n    t.estimated_walking_time,\n    t.point_count,\n    cp.cover_photo,\n    jsonb_agg(\n      jsonb_build_object(\n        'id', t.attraction_id,\n        'name', t.attraction_name,\n        'lat', t.lat::numeric,  -- ✅ FIXED: Added ::numeric cast\n        'lng', t.lng::numeric,  -- ✅ FIXED: Added ::numeric cast\n        'point_order', t.point_order,\n        'global_index', t.global_index\n      )\n      ORDER BY t.point_order\n    ) as points\n  FROM tour_points_expanded t\n  JOIN cities c ON c.id = t.city_id\n  LEFT JOIN city_translations ct\n    ON c.id = ct.city_id AND ct.language_code = language_code_param\n  LEFT JOIN cover_photos cp ON cp.tour_id = t.tour_id\n  GROUP BY\n    t.city_id,\n    c.city,\n    ct.city,\n    t.tour_id,\n    t.tour_order,\n    t.tour_name,\n    t.total_distance,\n    t.estimated_walking_time,\n    t.point_count,\n    cp.cover_photo;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_complete_tour_with_attractions",
    "parameters": "tour_id_param uuid, language_code_param text DEFAULT 'en'::text",
    "return_type": "jsonb",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_complete_tour_with_attractions(tour_id_param uuid, language_code_param text DEFAULT 'en'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  result JSONB;\nBEGIN\n  SELECT to_jsonb(tour_data.*) INTO result\n  FROM (\n    SELECT\n      gt.id,\n      gt.city_id,\n      gt.tour_id,\n      COALESCE(gtt.tour_name, gt.tour_name) AS tour_name,\n      COALESCE(gtt.description, gt.description) AS description,\n      gt.max_participants,\n      gt.total_distance,\n      gt.estimated_walking_time,\n      gt.point_count,\n      gt.start_point,\n      gt.end_point,\n      gt.created_at,\n      gt.updated_at,\n      (\n        SELECT jsonb_agg(\n          jsonb_build_object(\n            'point_order', tp.point_order,\n            'global_index', tp.global_index,\n            'attraction', jsonb_build_object(\n              'id', a.id,\n              'place_id', a.place_id,\n              'name', COALESCE(at.name, a.name),\n              'formatted_address', a.formatted_address,\n              'location', jsonb_build_object('lat', a.lat::numeric, 'lng', a.lng::numeric),\n              'ai_description', COALESCE(at.ai_description::jsonb, a.ai_description),\n              'photos', a.photos,\n              'rating', a.rating,\n              'types', a.types,\n              'audio_url', COALESCE(at.audio_url, a.audio_url)\n            )\n          )\n          ORDER BY tp.point_order\n        )\n        FROM tour_points tp\n        JOIN attractions a ON tp.attraction_id = a.id\n        LEFT JOIN attraction_translations at\n          ON at.attraction_id = a.id AND at.language_code = language_code_param\n        WHERE tp.tour_id = gt.id\n      ) AS points\n    FROM guided_tours gt\n    LEFT JOIN guided_tour_translations gtt\n      ON gtt.tour_id = gt.id AND gtt.language_code = language_code_param\n    WHERE gt.id = tour_id_param\n  ) AS tour_data;\n\n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_complete_tour_with_walking_paths",
    "parameters": "tour_id_param uuid, language_code_param text DEFAULT 'en'::text",
    "return_type": "jsonb",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_complete_tour_with_walking_paths(tour_id_param uuid, language_code_param text DEFAULT 'en'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nDECLARE\n  result JSONB;\nBEGIN\n  SELECT to_jsonb(tour_data.*) INTO result\n  FROM (\n    WITH tour_base AS (\n      SELECT\n        gt.id,\n        gt.city_id,\n        gt.tour_id,\n        COALESCE(gtt.tour_name, gt.tour_name) AS tour_name,\n        COALESCE(gtt.description, gt.description) AS description,\n        gt.max_participants,\n        gt.total_distance,\n        gt.estimated_walking_time,\n        gt.point_count,\n        gt.start_point,\n        gt.end_point,\n        gt.created_at,\n        gt.updated_at\n      FROM guided_tours gt\n      LEFT JOIN guided_tour_translations gtt\n        ON gtt.tour_id = gt.id AND gtt.language_code = language_code_param\n      WHERE gt.id = tour_id_param\n    )\n    SELECT\n      tb.*,\n      (\n        SELECT jsonb_agg(\n          jsonb_build_object(\n            'point_order', tp.point_order,\n            'global_index', tp.global_index,\n            'attraction', jsonb_build_object(\n              'id', a.id,\n              'place_id', a.place_id,\n              'name', COALESCE(at.name, a.name),\n              'formatted_address', a.formatted_address,\n              'location', jsonb_build_object('lat', a.lat::numeric, 'lng', a.lng::numeric),\n              'ai_description', COALESCE(at.ai_description::jsonb, a.ai_description),\n              'photos', a.photos,\n              'rating', a.rating,\n              'types', a.types,\n              'audio_url', COALESCE(at.audio_url, a.audio_url),\n              'distance_from_previous', a.distance_from_previous,\n              'walking_time_from_previous', a.walking_time_from_previous\n            )\n          )\n          ORDER BY tp.point_order\n        )\n        FROM tour_points tp\n        JOIN attractions a ON tp.attraction_id = a.id\n        LEFT JOIN attraction_translations at\n          ON at.attraction_id = a.id AND at.language_code = language_code_param\n        WHERE tp.tour_id = tb.id\n      ) AS points,\n      (\n        SELECT jsonb_agg(\n          jsonb_build_object(\n            'id', wp.id,\n            'from_attraction_id', wp.from_attraction_id,\n            'to_attraction_id', wp.to_attraction_id,\n            'path_coordinates', wp.path_coordinates,\n            'from_attraction', jsonb_build_object(\n              'id', from_attr.id,\n              'place_id', from_attr.place_id,\n              'name', COALESCE(from_trans.name, from_attr.name),\n              'location', jsonb_build_object('lat', from_attr.lat::numeric, 'lng', from_attr.lng::numeric),\n              'ai_description', COALESCE(from_trans.ai_description::jsonb, from_attr.ai_description),\n              'distance_from_previous', from_attr.distance_from_previous,\n              'walking_time_from_previous', from_attr.walking_time_from_previous\n            ),\n            'to_attraction', jsonb_build_object(\n              'id', to_attr.id,\n              'place_id', to_attr.place_id,\n              'name', COALESCE(to_trans.name, to_attr.name),\n              'location', jsonb_build_object('lat', to_attr.lat::numeric, 'lng', to_attr.lng::numeric),\n              'ai_description', COALESCE(to_trans.ai_description::jsonb, to_attr.ai_description),\n              'distance_from_previous', to_attr.distance_from_previous,\n              'walking_time_from_previous', to_attr.walking_time_from_previous\n            )\n          )\n          ORDER BY wp.id\n        )\n        FROM walking_paths wp\n        JOIN attractions from_attr ON wp.from_attraction_id = from_attr.id\n        JOIN attractions to_attr ON wp.to_attraction_id = to_attr.id\n        LEFT JOIN attraction_translations from_trans\n          ON from_trans.attraction_id = from_attr.id AND from_trans.language_code = language_code_param\n        LEFT JOIN attraction_translations to_trans\n          ON to_trans.attraction_id = to_attr.id AND to_trans.language_code = language_code_param\n        WHERE wp.tour_id = tb.id\n      ) AS walking_paths\n    FROM tour_base tb\n  ) AS tour_data;\n\n  RETURN result;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_tour_by_id",
    "parameters": "tour_id_param uuid, language_code_param text DEFAULT 'en'::text",
    "return_type": "TABLE(id uuid, city_id uuid, tour_id integer, tour_name character varying, description text, estimated_walking_time integer, total_distance integer, created_at timestamp with time zone, updated_at timestamp with time zone)",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_tour_by_id(tour_id_param uuid, language_code_param text DEFAULT 'en'::text)\n RETURNS TABLE(id uuid, city_id uuid, tour_id integer, tour_name character varying, description text, estimated_walking_time integer, total_distance integer, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT\n    gt.id,\n    gt.city_id,\n    gt.tour_id,\n    COALESCE(gtt.tour_name, gt.tour_name) as tour_name,\n    COALESCE(gtt.description, gt.description) as description,\n    gt.estimated_walking_time,\n    gt.total_distance,\n    gt.created_at,\n    gt.updated_at\n  FROM guided_tours gt\n  LEFT JOIN guided_tour_translations gtt\n    ON gt.id = gtt.tour_id AND gtt.language_code = language_code_param\n  WHERE gt.id = tour_id_param;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_tours_by_city_place_id",
    "parameters": "place_id_param text, language_code_param text DEFAULT 'en'::text",
    "return_type": "TABLE(id uuid, city_id uuid, tour_id integer, tour_name character varying, description text, estimated_walking_time integer, total_distance integer, created_at timestamp with time zone, updated_at timestamp with time zone)",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_tours_by_city_place_id(place_id_param text, language_code_param text DEFAULT 'en'::text)\n RETURNS TABLE(id uuid, city_id uuid, tour_id integer, tour_name character varying, description text, estimated_walking_time integer, total_distance integer, created_at timestamp with time zone, updated_at timestamp with time zone)\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT\n    gt.id,\n    gt.city_id,\n    gt.tour_id,\n    COALESCE(gtt.tour_name, gt.tour_name) AS tour_name,\n    COALESCE(gtt.description, gt.description) AS description,\n    gt.estimated_walking_time,\n    gt.total_distance,\n    gt.created_at,\n    gt.updated_at\n  FROM guided_tours gt\n  INNER JOIN cities c ON gt.city_id = c.id\n  LEFT JOIN guided_tour_translations gtt\n    ON gt.id = gtt.tour_id AND gtt.language_code = language_code_param\n  WHERE c.place_id = place_id_param\n  ORDER BY gt.tour_id;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_user_active_tours",
    "parameters": "user_id_param uuid, language_code_param text DEFAULT 'en'::text",
    "return_type": "TABLE(user_id uuid, purchase_id uuid, source text, purchase_date timestamp with time zone, quantity_total integer, quantity_completed integer, quantity_gifted integer, tour_id uuid, tour_name character varying, city character varying, country character varying, language_code text, place_id text, total_distance integer, estimated_walking_time integer, point_count integer, first_point_name character varying, first_point_address text, first_point_photos jsonb)",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_user_active_tours(user_id_param uuid, language_code_param text DEFAULT 'en'::text)\n RETURNS TABLE(user_id uuid, purchase_id uuid, source text, purchase_date timestamp with time zone, quantity_total integer, quantity_completed integer, quantity_gifted integer, tour_id uuid, tour_name character varying, city character varying, country character varying, language_code text, place_id text, total_distance integer, estimated_walking_time integer, point_count integer, first_point_name character varying, first_point_address text, first_point_photos jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT\n    tpur.user_id,\n    tpur.id,\n    tpur.source::text,\n    tpur.purchase_date,\n    tpur.quantity_total,\n    tpur.quantity_completed,\n    tpur.quantity_gifted,\n    gt.id,\n    COALESCE(gtt.tour_name, gt.tour_name) AS tour_name,\n    COALESCE(ct.city, c.city) AS city,\n    COALESCE(ct.country, c.country) AS country,\n    tpur.language_code::text,\n    c.place_id::text,\n    gt.total_distance,\n    gt.estimated_walking_time,\n    gt.point_count,\n    COALESCE(first_trans.name, first_point.name) AS first_point_name,\n    first_point.formatted_address AS first_point_address,\n    first_point.photos AS first_point_photos\n  FROM tour_purchases tpur\n  JOIN guided_tours gt ON tpur.tour_id = gt.id\n  JOIN cities c ON gt.city_id = c.id\n  LEFT JOIN guided_tour_translations gtt\n    ON gtt.tour_id = gt.id AND gtt.language_code = language_code_param\n  LEFT JOIN city_translations ct\n    ON ct.city_id = c.id AND ct.language_code = language_code_param\n  LEFT JOIN tour_points tp\n    ON gt.id = tp.tour_id AND tp.point_order = 1\n  LEFT JOIN attractions first_point\n    ON tp.attraction_id = first_point.id\n  LEFT JOIN attraction_translations first_trans\n    ON first_trans.attraction_id = first_point.id\n    AND first_trans.language_code = language_code_param\n  WHERE tpur.user_id = user_id_param\n    AND tpur.quantity_total > tpur.quantity_gifted\n  ORDER BY tpur.purchase_date DESC;\nEND;\n$function$\n"
  },
  {
    "function_name": "get_user_tour_history",
    "parameters": "user_id_param uuid, language_code_param text DEFAULT 'en'::text",
    "return_type": "TABLE(user_id uuid, purchase_id uuid, source text, purchase_date timestamp with time zone, quantity_total integer, quantity_completed integer, quantity_gifted integer, tour_id uuid, tour_name character varying, city character varying, country character varying, place_id text, total_distance integer, estimated_walking_time integer, point_count integer, first_point_name character varying, first_point_address text, first_point_photos jsonb)",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_user_tour_history(user_id_param uuid, language_code_param text DEFAULT 'en'::text)\n RETURNS TABLE(user_id uuid, purchase_id uuid, source text, purchase_date timestamp with time zone, quantity_total integer, quantity_completed integer, quantity_gifted integer, tour_id uuid, tour_name character varying, city character varying, country character varying, place_id text, total_distance integer, estimated_walking_time integer, point_count integer, first_point_name character varying, first_point_address text, first_point_photos jsonb)\n LANGUAGE plpgsql\n STABLE\nAS $function$\nBEGIN\n  RETURN QUERY\n  SELECT\n    tpur.user_id,\n    tpur.id,\n    tpur.source,\n    tpur.purchase_date,\n    tpur.quantity_total,\n    tpur.quantity_completed,\n    tpur.quantity_gifted,\n    gt.id,\n    COALESCE(gtt.tour_name, gt.tour_name) AS tour_name,\n    COALESCE(ct.city, c.city) AS city,\n    COALESCE(ct.country, c.country) AS country,\n    c.place_id,\n    gt.total_distance,\n    gt.estimated_walking_time,\n    gt.point_count,\n    COALESCE(first_trans.name, first_point.name) AS first_point_name,\n    first_point.formatted_address AS first_point_address,\n    first_point.photos AS first_point_photos\n  FROM tour_purchases tpur\n  JOIN guided_tours gt ON tpur.tour_id = gt.id\n  JOIN cities c ON gt.city_id = c.id\n  LEFT JOIN guided_tour_translations gtt\n    ON gtt.tour_id = gt.id AND gtt.language_code = language_code_param\n  LEFT JOIN city_translations ct\n    ON ct.city_id = c.id AND ct.language_code = language_code_param\n  LEFT JOIN tour_points tp\n    ON gt.id = tp.tour_id AND tp.point_order = 1\n  LEFT JOIN attractions first_point\n    ON tp.attraction_id = first_point.id\n  LEFT JOIN attraction_translations first_trans\n    ON first_trans.attraction_id = first_point.id\n    AND first_trans.language_code = language_code_param\n  WHERE tpur.user_id = user_id_param\n    AND tpur.quantity_completed > 0\n  ORDER BY tpur.updated_at DESC;\nEND;\n$function$\n"
  },
  {
    "function_name": "invite_user_to_tour",
    "parameters": "sender_user_id uuid, p_recipient_email character varying, purchase_id uuid",
    "return_type": "boolean",
    "full_definition": "CREATE OR REPLACE FUNCTION public.invite_user_to_tour(sender_user_id uuid, p_recipient_email character varying, purchase_id uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    recipient_user_id uuid;\n    purchase_record tour_purchases%ROWTYPE;\n    sender_email text;\nBEGIN\n    -- Lock the purchase row to avoid race conditions\n    SELECT * INTO purchase_record\n    FROM tour_purchases\n    WHERE id = purchase_id\n      AND user_id = sender_user_id\n    FOR UPDATE;\n\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Purchase not found or not owned by sender';\n    END IF;\n\n    SELECT email INTO sender_email\n    FROM users\n    WHERE id = sender_user_id;\n\n    IF sender_email IS NULL THEN\n        RAISE EXCEPTION 'Sender not found';\n    END IF;\n\n    IF lower(sender_email) = lower(p_recipient_email) THEN\n        RAISE EXCEPTION 'You cannot gift a tour to yourself';\n    END IF;\n\n    -- Enforce \\\"always keep one slot\\\" rule\n    IF purchase_record.quantity_total <= 1 THEN\n        RAISE EXCEPTION 'Purchase cannot be gifted (only one slot available)';\n    END IF;\n\n    IF purchase_record.quantity_gifted >= purchase_record.quantity_total - 1 THEN\n        RAISE EXCEPTION 'No shareable quantity remaining for this purchase';\n    END IF;\n\n    -- Locate recipient if they already have an account\n    SELECT id INTO recipient_user_id\n    FROM users\n    WHERE email = p_recipient_email;\n\n    INSERT INTO tour_invitations (\n        sender_id,\n        recipient_email,\n        tour_purchase_id,\n        status\n    ) VALUES (\n        sender_user_id,\n        p_recipient_email,\n        purchase_id,\n        'pending'\n    );\n\n    -- Mark slot as gifted for the owner\n    UPDATE tour_purchases\n    SET quantity_gifted = quantity_gifted + 1,\n        updated_at = NOW()\n    WHERE id = purchase_id;\n\n    -- If the recipient already has an account, create their purchase immediately\n    IF recipient_user_id IS NOT NULL THEN\n        INSERT INTO tour_purchases (\n            user_id,\n            tour_id,\n            quantity_total,\n            quantity_completed,\n            quantity_gifted,\n            source,\n            narration_type,\n            language_code\n        )\n        VALUES (\n            recipient_user_id,\n            purchase_record.tour_id,\n            1,\n            0,\n            0,\n            'gift',\n            purchase_record.narration_type,\n            purchase_record.language_code\n        );\n\n        UPDATE tour_invitations\n        SET status = 'accepted',\n            accepted_date = NOW(),\n            updated_at = NOW()\n        WHERE tour_purchase_id = purchase_id\n          AND sender_id = sender_user_id\n          AND recipient_email = p_recipient_email\n          AND status = 'pending';\n    END IF;\n\n    RETURN TRUE;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE WARNING 'Error in invite_user_to_tour: %', SQLERRM;\n        RAISE;\nEND;\n$function$\n"
  },
  {
    "function_name": "request_city_status",
    "parameters": "place_id_param character varying, language_code_param text DEFAULT 'en'::text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.request_city_status(place_id_param character varying, language_code_param text DEFAULT 'en'::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    city_id_found UUID;\n    processing_record RECORD;\n    api_result JSON;\n    progress_value INTEGER;\nBEGIN\n    -- 1. Vérifier si la ville existe déjà\n    SELECT id INTO city_id_found\n    FROM cities\n    WHERE place_id = place_id_param;\n\n    -- Si la ville existe, retourner son ID pour que Flutter puisse continuer\n    IF city_id_found IS NOT NULL THEN\n        -- Nettoyer l'entrée processing si elle existe (ville maintenant prête)\n        DELETE FROM processing_city WHERE place_id = place_id_param;\n\n        RETURN json_build_object(\n            'status', 'ready',\n            'city_id', city_id_found,\n            'language_code', language_code_param  -- ← Include in response\n        );\n    END IF;\n\n    -- 2. Vérifier si le traitement est déjà en cours\n    SELECT * INTO processing_record\n    FROM processing_city\n    WHERE place_id = place_id_param;\n\n    IF processing_record IS NOT NULL THEN\n        -- Vérifier si trop ancien (3+ minutes) = Traitement HTTP probablement bloqué\n        IF processing_record.requested_at < NOW() - INTERVAL '3 minutes' THEN\n            -- Si trop ancien, considérer comme bloqué et permettre retry\n            DELETE FROM processing_city WHERE place_id = place_id_param;\n        ELSE\n            -- Traitement en cours OU erreur: retourner le statut actuel\n            RETURN json_build_object(\n                'status', processing_record.status,\n                'requested_at', processing_record.requested_at,\n                'language_code', language_code_param,  -- ← Include in response\n                'progress_percent', processing_record.progress_percent,\n                'message', CASE\n                    WHEN processing_record.status = 'error' THEN 'Previous generation failed'\n                    ELSE 'City data is being generated...'\n                END\n            );\n        END IF;\n    END IF;\n\n    -- 3. Démarrer un nouveau traitement\n    BEGIN\n        -- Insérer dans processing_city (mutex via contrainte unique)\n        INSERT INTO processing_city (place_id, status, requested_at, progress_percent)\n        VALUES (place_id_param, 'processing', NOW(), 0);\n\n        -- Appel API VPS (fonction séparée pour la maintenabilité)\n        SELECT trigger_lambda_generation(place_id_param, 'standard', language_code_param) INTO api_result;\n\n        IF NOT (api_result->>'success')::boolean THEN\n            -- Nettoyer en cas d'échec et retourner le message d'erreur détaillé\n            DELETE FROM processing_city WHERE place_id = place_id_param;\n            RETURN json_build_object(\n                'status', 'error',\n                'message', api_result->>'error_message'\n            );\n        END IF;\n\n        -- Succès, traitement démarré\n        RETURN json_build_object(\n            'status', 'processing',\n            'requested_at', NOW(),\n            'language_code', language_code_param,  -- ← Include in response\n            'progress_percent', 3,\n            'message', 'City data generation started'\n        );\n\n    EXCEPTION\n        WHEN unique_violation THEN\n            -- Concurrent request, traitement déjà en cours\n            SELECT progress_percent\n            INTO progress_value\n            FROM processing_city\n            WHERE place_id = place_id_param\n            LIMIT 1;\n\n            RETURN json_build_object(\n                'status', 'processing',\n                'language_code', language_code_param,  -- ← Include in response\n                'progress_percent', progress_value,\n                'message', 'City data generation already in progress'\n            );\n        WHEN OTHERS THEN\n            -- Nettoyer en cas d'erreur\n            DELETE FROM processing_city WHERE place_id = place_id_param;\n            RETURN json_build_object(\n                'status', 'error',\n                'message', 'Failed to initiate city data generation'\n            );\n    END;\nEND;\n$function$\n"
  },
  {
    "function_name": "request_tour_full_generation",
    "parameters": "tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.request_tour_full_generation(tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    total_points INTEGER;\n    points_with_audio INTEGER;\n    processing_record RECORD;\n\tprogress_percent_value INTEGER;\n    api_call_success BOOLEAN;\n    user_has_purchase BOOLEAN;\n    owned_languages json := '[]'::json;\n    credit_result json;\n    credits_consumed BOOLEAN := false;\n    consumed_credits INTEGER := 0;\nBEGIN\n    PERFORM set_config('request.jwt.claim.role', 'service_role', true);\n    language_code_param := COALESCE(NULLIF(language_code_param, ''), 'en');\n\n    -- 1. Verify user exists\n    IF NOT EXISTS (SELECT 1 FROM users WHERE id = user_id_param) THEN\n        RETURN json_build_object(\n            'status', 'error',\n            'message', 'User not found',\n            'owned_languages', '[]'::json\n        );\n    END IF;\n\n    -- 2. Existing purchase?\n    SELECT EXISTS(\n        SELECT 1 FROM tour_purchases\n        WHERE user_id = user_id_param\n          AND tour_id = tour_id_param\n          AND narration_type = narration_type_param\n          AND language_code = language_code_param\n          AND quantity_total > quantity_gifted\n    ) INTO user_has_purchase;\n\n    SELECT COALESCE(json_agg(\n        json_build_object(\n            'language_code', tp.language_code,\n            'purchase_id', tp.id\n        )\n    ), '[]'::json)\n    INTO owned_languages\n    FROM tour_purchases tp\n    WHERE tp.user_id = user_id_param\n      AND tp.tour_id = tour_id_param\n      AND tp.narration_type = narration_type_param\n      AND tp.quantity_total > tp.quantity_gifted;\n\n    -- 3. Points already generated?\n    SELECT\n        COUNT(*) AS total,\n        COUNT(\n            CASE\n                WHEN COALESCE(at.audio_url, a.audio_url)->>narration_type_param IS NOT NULL THEN 1\n            END\n        ) AS with_audio\n    INTO total_points, points_with_audio\n    FROM tour_points tp\n    JOIN attractions a ON tp.attraction_id = a.id\n    LEFT JOIN attraction_translations at\n      ON at.attraction_id = tp.attraction_id\n     AND at.language_code = language_code_param\n    WHERE tp.tour_id = tour_id_param;\n\n    IF total_points > 0 AND total_points = points_with_audio THEN\n        IF NOT user_has_purchase THEN \n            credit_result := consume_tour_credits_for_generation(\n                tour_id_param => tour_id_param,\n                user_id_param => user_id_param\n            );\n\n            IF COALESCE((credit_result->>'success')::boolean, false) IS DISTINCT FROM TRUE THEN\n                RETURN json_build_object(\n                    'status', 'error',\n                    'message', COALESCE(credit_result->>'message', 'Insufficient credits'),\n                    'owned_languages', owned_languages\n                );\n            END IF;\n\n            INSERT INTO tour_purchases (user_id, tour_id, narration_type, language_code, purchase_date)\n            VALUES (user_id_param, tour_id_param, narration_type_param, language_code_param, NOW());\n\n            SELECT COALESCE(json_agg(\n                json_build_object(\n                    'language_code', tp.language_code,\n                    'purchase_id', tp.id\n                )\n            ), '[]'::json)\n            INTO owned_languages\n            FROM tour_purchases tp\n            WHERE tp.user_id = user_id_param\n              AND tp.tour_id = tour_id_param\n              AND tp.narration_type = narration_type_param\n              AND tp.quantity_total > tp.quantity_gifted;\n        END IF;\n\n        DELETE FROM processing_tour_generation\n        WHERE tour_id = tour_id_param\n          AND narration_type = narration_type_param\n          AND language_code = language_code_param;\n\n        RETURN json_build_object(\n            'status', 'ready',\n            'total_points', total_points,\n            'completed_points', points_with_audio,\n            'user_has_purchase', true,\n            'narration_type', narration_type_param,\n            'language_code', language_code_param,\n            'message', 'All tour audio files are ready',\n            'owned_languages', owned_languages\n        );\n    END IF;\n\n    -- 4. Processing already in progress?\n    SELECT * INTO processing_record\n    FROM processing_tour_generation\n    WHERE tour_id = tour_id_param\n      AND narration_type = narration_type_param\n      AND language_code = language_code_param;\n\nraise notice 'processing_record %', processing_record;\nraise notice '--tour_id_param %', tour_id_param; \nraise notice '--narration_type_param %', narration_type_param; \nraise notice '--language_code %', language_code_param; \n\n    IF FOUND THEN\n        IF processing_record.status = 'error'\n           OR processing_record.requested_at < NOW() - INTERVAL '5 minutes' THEN\n            DELETE FROM processing_tour_generation\n            WHERE tour_id = tour_id_param\n              AND narration_type = narration_type_param\n              AND language_code = language_code_param;\n        ELSE\n            RETURN json_build_object(\n                'status', 'processing',\n                'requested_at', processing_record.requested_at,\n                'total_points', total_points,\n                'completed_points', points_with_audio,\n                'narration_type', narration_type_param,\n                'language_code', language_code_param,\n                'message', 'Tour audio generation in progress...',\n\t\t\t\t'progress_percent', processing_record.progress_percent,\n                'owned_languages', owned_languages\n            );\n        END IF;\n    END IF;\n\n    -- 5. Consume credits when needed (no prior purchase)\n    IF NOT user_has_purchase THEN\n        credit_result := consume_tour_credits_for_generation(\n            tour_id_param => tour_id_param,\n            user_id_param => user_id_param\n        );\n\n        IF COALESCE((credit_result->>'success')::boolean, false) IS DISTINCT FROM TRUE THEN\n            RETURN json_build_object(\n                'status', 'error',\n                'message', COALESCE(credit_result->>'message', 'Insufficient credits'),\n                'owned_languages', owned_languages\n            );\n        END IF;\n\n        consumed_credits := COALESCE((credit_result->>'required_credits')::integer, 0);\n        credits_consumed := consumed_credits > 0;\n    END IF;\n\n    -- 6. Start new processing\n    BEGIN\n        INSERT INTO processing_tour_generation (tour_id, narration_type, language_code, status, requested_at, progress_percent)\n        VALUES (tour_id_param, narration_type_param, language_code_param, 'processing', NOW(), 0);\n\n        SELECT trigger_tour_full_generation(\n            tour_id_param,\n            user_id_param,\n            narration_type_param,\n            language_code_param\n        ) INTO api_call_success;\n\n        IF NOT api_call_success THEN\n            IF credits_consumed AND consumed_credits > 0 THEN\n                UPDATE users\n                SET credits = credits + consumed_credits,\n                    updated_at = NOW()\n                WHERE id = user_id_param;\n                credits_consumed := false;\n            END IF;\n\n            DELETE FROM processing_tour_generation\n            WHERE tour_id = tour_id_param\n              AND narration_type = narration_type_param\n              AND language_code = language_code_param;\n\n            RETURN json_build_object(\n                'status', 'error',\n                'message', 'Failed to start tour audio generation',\n                'owned_languages', owned_languages\n            );\n        END IF;\n\n        IF NOT user_has_purchase THEN\n            INSERT INTO tour_purchases (user_id, tour_id, narration_type, language_code, purchase_date)\n            VALUES (user_id_param, tour_id_param, narration_type_param, language_code_param, NOW());\n            user_has_purchase := true;\n        END IF;\n\n        SELECT COALESCE(json_agg(\n            json_build_object(\n                'language_code', tp.language_code,\n                'purchase_id', tp.id\n            )\n        ), '[]'::json)\n        INTO owned_languages\n        FROM tour_purchases tp\n        WHERE tp.user_id = user_id_param\n          AND tp.tour_id = tour_id_param\n          AND tp.narration_type = narration_type_param\n          AND tp.quantity_total > tp.quantity_gifted;\n\n        RETURN json_build_object(\n            'status', 'processing',\n            'requested_at', NOW(),\n            'total_points', total_points,\n            'completed_points', points_with_audio,\n            'narration_type', narration_type_param,\n            'language_code', language_code_param,\n            'message', 'Tour audio generation started',\n\t\t\t'progress_percent', 3,\n            'owned_languages', owned_languages\n        );\n\n    EXCEPTION\n        WHEN unique_violation THEN\n\n\t\tSELECT progress_percent\n            INTO progress_percent_value\n            FROM processing_tour_generation\n            WHERE tour_id = tour_id_param\n              AND narration_type = narration_type_param\n              AND language_code = language_code_param\n            LIMIT 1;\n\n            RETURN json_build_object(\n                'status', 'processing',\n                'narration_type', narration_type_param,\n                'language_code', language_code_param,\n                'message', 'Tour audio generation already in progress',\n\t\t\t\t'progress_percent', progress_percent_value,\n                'owned_languages', owned_languages\n            );\n        WHEN OTHERS THEN\n            IF credits_consumed AND consumed_credits > 0 THEN\n                UPDATE users\n                SET credits = credits + consumed_credits,\n                    updated_at = NOW()\n                WHERE id = user_id_param;\n                credits_consumed := false;\n            END IF;\n\n            DELETE FROM processing_tour_generation\n            WHERE tour_id = tour_id_param\n              AND narration_type = narration_type_param\n              AND language_code = language_code_param;\n\n            RETURN json_build_object(\n                'status', 'error',\n                'message', 'Failed to initiate tour audio generation: ' || SQLERRM,\n                'owned_languages', owned_languages\n            );\n    END;\nEND;\n$function$\n"
  },
  {
    "function_name": "request_tour_preview_audio",
    "parameters": "tour_id_param uuid",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.request_tour_preview_audio(tour_id_param uuid)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    first_attraction_audio TEXT;\n    processing_record RECORD;\n    api_call_success BOOLEAN;\nBEGIN\n    -- 1. Vérifier si le premier point a déjà un audio\n    SELECT a.audio_url INTO first_attraction_audio\n    FROM guided_tours gt\n    JOIN tour_points tp ON gt.id = tp.tour_id\n    JOIN attractions a ON tp.attraction_id = a.id\n    WHERE gt.id = tour_id_param\n    ORDER BY tp.point_order ASC\n    LIMIT 1;\n\n    -- Si l'audio du premier point existe, le retourner\n    IF first_attraction_audio IS NOT NULL THEN\n        -- Nettoyer l'entrée processing si elle existe\n        DELETE FROM processing_tour_preview WHERE tour_id = tour_id_param;\n        \n        RETURN json_build_object(\n            'status', 'ready',\n            'audio_url', first_attraction_audio,\n            'message', 'Preview audio is available'\n        );\n    END IF;\n\n    -- 2. Vérifier si le traitement est déjà en cours\n    SELECT * INTO processing_record \n    FROM processing_tour_preview \n    WHERE tour_id = tour_id_param;\n\n    IF processing_record IS NOT NULL THEN\n        -- Vérifier timeout (3 minutes)\n        IF processing_record.requested_at < NOW() - INTERVAL '3 minutes' THEN\n            DELETE FROM processing_tour_preview WHERE tour_id = tour_id_param;\n        ELSE\n            -- Traitement en cours\n            RETURN json_build_object(\n                'status', 'processing',\n                'requested_at', processing_record.requested_at,\n                'message', 'Preview audio is being generated...'\n            );\n        END IF;\n    END IF;\n\n    -- 3. Démarrer un nouveau traitement\n    BEGIN\n        -- Insérer dans processing_tour_preview (mutex)\n        INSERT INTO processing_tour_preview (tour_id, status, requested_at)\n        VALUES (tour_id_param, 'processing', NOW());\n\n        -- Déclencher la génération API\n        SELECT trigger_tour_preview_generation(tour_id_param) INTO api_call_success;\n\n        IF NOT api_call_success THEN\n            DELETE FROM processing_tour_preview WHERE tour_id = tour_id_param;\n            RETURN json_build_object(\n                'status', 'error',\n                'message', 'Failed to start preview audio generation'\n            );\n        END IF;\n\n        RETURN json_build_object(\n            'status', 'processing',\n            'requested_at', NOW(),\n            'message', 'Preview audio generation started'\n        );\n\n    EXCEPTION\n        WHEN unique_violation THEN\n            RETURN json_build_object(\n                'status', 'processing',\n                'message', 'Preview audio generation already in progress'\n            );\n        WHEN OTHERS THEN\n            DELETE FROM processing_tour_preview WHERE tour_id = tour_id_param;\n            RETURN json_build_object(\n                'status', 'error',\n                'message', 'Failed to initiate preview audio generation'\n            );\n    END;\nEND;\n$function$\n"
  },
  {
    "function_name": "trigger_claim_pending_invitations",
    "parameters": "",
    "return_type": "trigger",
    "full_definition": "CREATE OR REPLACE FUNCTION public.trigger_claim_pending_invitations()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nBEGIN\n    PERFORM claim_pending_invitations(NEW.id, NEW.email);\n    RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "trigger_lambda_generation",
    "parameters": "place_id_param character varying",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.trigger_lambda_generation(place_id_param character varying)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    api_base_url TEXT;\n    request_url TEXT;\n    payload JSON;\nBEGIN\n    api_base_url := COALESCE(NULLIF(public.narrando_api_base_url(), ''), 'http://localhost:5000');\n    request_url := api_base_url || '/generate-city-data';\n\n    payload := json_build_object(\n        'place_id', place_id_param,\n        'skip_audio', true,\n        'skip_descriptions', true,\n        'token', 'o2ESQAYiP41yAO33OhRDmcqosaTsPLTdoPfpK0xtUdhtMZTfcJewm9aK2Kz7Jq8MV'\n    );\n\n    PERFORM net.http_post(\n        url := request_url,\n        headers := '{\"Content-Type\": \"application/json\"}'::jsonb,\n        body := payload::jsonb\n    );\n\n    RAISE NOTICE 'Generation request sent for place_id: % (API %)', place_id_param, request_url;\n\n    RETURN json_build_object(\n        'success', true,\n        'message', 'Generation request sent successfully'\n    );\n\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE NOTICE 'Error sending generation request: %', SQLERRM;\n        RETURN json_build_object(\n            'success', false,\n            'error_message', 'Failed to send request to API: ' || SQLERRM\n        );\nEND;\n$function$"
  },
  {
    "function_name": "trigger_lambda_generation",
    "parameters": "place_id_param character varying, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.trigger_lambda_generation(place_id_param character varying, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text)\n RETURNS json\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    api_base_url TEXT;\n    request_url TEXT;\n    payload JSON;\nBEGIN\n    api_base_url := COALESCE(NULLIF(public.narrando_api_base_url(), ''), 'http://localhost:5000');\n    request_url := api_base_url || '/generate-city-data';\n\n    payload := json_build_object(\n        'place_id', place_id_param,\n        'narration_type', narration_type_param,\n        'language_code', language_code_param,\n        'skip_audio', true,\n        'skip_descriptions', true,\n        'token', 'o2ESQAYiP41yAO33OhRDmcqosaTsPLTdoPfpK0xtUdhtMZTfcJewm9aK2Kz7Jq8MV'\n    );\n\n    PERFORM net.http_post(\n        url := request_url,\n        headers := '{\"Content-Type\": \"application/json\"}'::jsonb,\n        body := payload::jsonb\n    );\n\n    RAISE NOTICE 'Generation request sent for place_id: %, narration: %, language: % (API %)',\n        place_id_param, narration_type_param, language_code_param, request_url;\n\n    RETURN json_build_object(\n        'success', true,\n        'message', 'Generation request sent successfully'\n    );\n\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE NOTICE 'Error sending generation request: %', SQLERRM;\n        RETURN json_build_object(\n            'success', false,\n            'error_message', 'Failed to send request to API: ' || SQLERRM\n        );\nEND;\n$function$"
  },
  {
    "function_name": "trigger_send_invitation_email",
    "parameters": "",
    "return_type": "trigger",
    "full_definition": "CREATE OR REPLACE FUNCTION public.trigger_send_invitation_email()\n RETURNS trigger\n LANGUAGE plpgsql\n SECURITY DEFINER\n SET search_path TO 'public'\nAS $function$\nDECLARE\n    endpoint text;\n    service_key text;\n    app_url text := 'https://narrando.app';\n    sender_name text;\n    purchase_lang text;\nBEGIN\n    SELECT value INTO endpoint FROM app_settings WHERE key = 'send_invitation_email_url';\n    SELECT value INTO service_key FROM app_settings WHERE key = 'service_role_key';\n    SELECT COALESCE(value, app_url) INTO app_url FROM app_settings WHERE key = 'narrando_app_url';\n\n    IF endpoint IS NULL OR endpoint = '' THEN\n        RAISE NOTICE 'send_invitation_email_url not configured';\n        RETURN NEW;\n    END IF;\n\n    SELECT COALESCE(first_name, last_name, email)\n    INTO sender_name\n    FROM users\n    WHERE id = NEW.sender_id;\n\n    IF sender_name IS NULL THEN\n        sender_name := 'Narrando';\n    END IF;\n\n    SELECT language_code\n    INTO purchase_lang\n    FROM tour_purchases\n    WHERE id = NEW.tour_purchase_id;\n\n    PERFORM http_request(\n        url := endpoint,\n        method := 'POST',\n        headers := jsonb_build_object(\n            'Content-Type', 'application/json',\n            'Authorization', 'Bearer ' || COALESCE(service_key, '')\n        ),\n        body := jsonb_build_object(\n            'recipientEmail', NEW.recipient_email,\n            'recipientName', NEW.recipient_name,\n            'senderName', sender_name,\n            'locale', purchase_lang,\n            'appUrl', app_url\n        )\n    );\n\n    RETURN NEW;\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE WARNING 'Failed to call send-invitation-email function: %', SQLERRM;\n        RETURN NEW;\nEND;\n$function$\n"
  },
  {
    "function_name": "trigger_tour_full_generation",
    "parameters": "tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text",
    "return_type": "boolean",
    "full_definition": "CREATE OR REPLACE FUNCTION public.trigger_tour_full_generation(tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$DECLARE\n    api_base_url TEXT;\n    request_url TEXT;\n    request_payload JSONB;\nBEGIN\n    api_base_url := COALESCE(NULLIF(public.narrando_api_base_url(), ''), 'http://localhost:5000');\n    request_url := api_base_url || '/generate-complete-audio/' || tour_id_param;\n\n    request_payload := jsonb_build_object(\n        'user_id', user_id_param,\n        'narration_type', narration_type_param,\n        'force_regenerate', false,\n        'skip_audio', false,\n        'token', 'o2ESQAYiP41yAO33OhRDmcqosaTsPLTdoPfpK0xtUdhtMZTfcJewm9aK2Kz7Jq8MV'\n    );\n\n    PERFORM net.http_post(\n        url     := request_url,\n        headers := '{\"Content-Type\": \"application/json\"}'::jsonb,\n        body    := request_payload\n    );\n\n    RAISE NOTICE 'Full generation request sent for tour %, narration % (API %)', tour_id_param, narration_type_param, request_url;\n    RETURN TRUE;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE NOTICE 'Error calling full generation endpoint: %', SQLERRM;\n        RETURN FALSE;\nEND;$function$"
  },
  {
    "function_name": "trigger_tour_full_generation",
    "parameters": "tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text",
    "return_type": "boolean",
    "full_definition": "CREATE OR REPLACE FUNCTION public.trigger_tour_full_generation(tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    api_base_url TEXT;\n    request_url TEXT;\n    request_payload JSONB;\nBEGIN\n    api_base_url := COALESCE(NULLIF(public.narrando_api_base_url(), ''), 'http://localhost:5000');\n    request_url := api_base_url || '/generate-complete-audio/' || tour_id_param;\n\n    request_payload := jsonb_build_object(\n        'user_id', user_id_param,\n        'narration_type', narration_type_param,\n        'language_code', language_code_param,\n        'force_regenerate', false,\n        'skip_audio', false,\n        'token', 'o2ESQAYiP41yAO33OhRDmcqosaTsPLTdoPfpK0xtUdhtMZTfcJewm9aK2Kz7Jq8MV'\n    );\n\n    PERFORM net.http_post(\n        url     := request_url,\n        headers := '{\"Content-Type\": \"application/json\"}'::jsonb,\n        body    := request_payload\n    );\n\n    RAISE NOTICE 'Full generation request sent for tour %, narration %, language % (API %)',\n        tour_id_param, narration_type_param, language_code_param, request_url;\n    RETURN TRUE;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE NOTICE 'Error calling full generation endpoint: %', SQLERRM;\n        RETURN FALSE;\nEND;\n$function$"
  },
  {
    "function_name": "trigger_tour_preview_generation",
    "parameters": "tour_id_param uuid",
    "return_type": "boolean",
    "full_definition": "CREATE OR REPLACE FUNCTION public.trigger_tour_preview_generation(tour_id_param uuid)\n RETURNS boolean\n LANGUAGE plpgsql\n SECURITY DEFINER\nAS $function$\nDECLARE\n    api_base_url TEXT;\n    request_url TEXT;\n    request_payload JSON;\n    request_id BIGINT;\nBEGIN\n    api_base_url := COALESCE(NULLIF(public.narrando_api_base_url(), ''), 'http://localhost:5000');\n    request_url := api_base_url || '/generate-preview-audio/' || tour_id_param;\n\n    request_payload := json_build_object(\n        'attraction_index', 0,\n        'force_regenerate', false,\n        'skip_audio', false,\n        'token', 'narrando-supabase-lambda-token-2024'\n    );\n\n    PERFORM net.http_post(\n        url := request_url,\n        headers := '{\"Content-Type\": \"application/json\"}'::jsonb,\n        body := request_payload::jsonb\n    );\n\n    RAISE NOTICE 'Preview request sent for tour_id: % (API %)', tour_id_param, request_url;\n\n    RETURN TRUE;\n\nEXCEPTION\n    WHEN OTHERS THEN\n        RAISE NOTICE 'Error calling preview endpoint: %', SQLERRM;\n        RETURN FALSE;\nEND;\n$function$"
  },
  {
    "function_name": "update_updated_at_column",
    "parameters": "",
    "return_type": "trigger",
    "full_definition": "CREATE OR REPLACE FUNCTION public.update_updated_at_column()\n RETURNS trigger\n LANGUAGE plpgsql\nAS $function$\r\nBEGIN\r\n    NEW.updated_at = NOW();\r\n    RETURN NEW;\r\nEND;\r\n$function$\n"
  },
  {
    "function_name": "get_complete_user_tour_with_attractions",
    "parameters": "tour_id_param uuid, language_code_param text DEFAULT 'en'::text",
    "return_type": "jsonb",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_complete_user_tour_with_attractions(tour_id_param uuid, language_code_param text DEFAULT 'en'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RAISE EXCEPTION 'get_complete_user_tour_with_attractions not implemented';\nEND;\n$function$\n"
  },
  {
    "function_name": "get_active_user_tour_model",
    "parameters": "tour_id_param uuid, language_code_param text DEFAULT 'en'::text",
    "return_type": "jsonb",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_active_user_tour_model(tour_id_param uuid, language_code_param text DEFAULT 'en'::text)\n RETURNS jsonb\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RAISE EXCEPTION 'get_active_user_tour_model not implemented';\nEND;\n$function$\n"
  },
  {
    "function_name": "request_user_tour_full_generation",
    "parameters": "tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.request_user_tour_full_generation(tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RAISE EXCEPTION 'request_user_tour_full_generation not implemented';\nEND;\n$function$\n"
  },
  {
    "function_name": "check_user_tour_generation_status",
    "parameters": "tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.check_user_tour_generation_status(tour_id_param uuid, user_id_param uuid, narration_type_param text DEFAULT 'standard'::text, language_code_param text DEFAULT 'en'::text)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RAISE EXCEPTION 'check_user_tour_generation_status not implemented';\nEND;\n$function$\n"
  },
  {
    "function_name": "invite_user_to_user_tour",
    "parameters": "sender_user_id uuid, tour_purchase_id uuid, recipient_email text",
    "return_type": "boolean",
    "full_definition": "CREATE OR REPLACE FUNCTION public.invite_user_to_user_tour(sender_user_id uuid, tour_purchase_id uuid, recipient_email text)\n RETURNS boolean\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RAISE EXCEPTION 'invite_user_to_user_tour not implemented';\nEND;\n$function$\n"
  },
  {
    "function_name": "claim_pending_user_invitations",
    "parameters": "p_user_id uuid, p_email text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.claim_pending_user_invitations(p_user_id uuid, p_email text)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RAISE EXCEPTION 'claim_pending_user_invitations not implemented';\nEND;\n$function$\n"
  },
  {
    "function_name": "get_user_active_custom_tours",
    "parameters": "p_user_id uuid, p_language_code text DEFAULT 'en'::text",
    "return_type": "json",
    "full_definition": "CREATE OR REPLACE FUNCTION public.get_user_active_custom_tours(p_user_id uuid, p_language_code text DEFAULT 'en'::text)\n RETURNS json\n LANGUAGE plpgsql\nAS $function$\nBEGIN\n    RAISE EXCEPTION 'get_user_active_custom_tours not implemented';\nEND;\n$function$\n"
  }
]